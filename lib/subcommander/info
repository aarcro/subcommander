#!/bin/sh
# Description: Prints some information about the environment.
set -e

# Many of the discovery and variables within this script is duplicated in
# subcommander proper, but I prefer that to forcing subcommander to needlessly
# export many environment variables.

sc_env_prefix="`echo $SUBCOMMANDER|tr 'a-z ' 'A-Z_'`"
sc_ctx_envname="${sc_env_prefix}_CONTEXT"
eval "my_exec_path=\$${sc_env_prefix}_EXEC_PATH"
sc_rcfile="$HOME/.$SUBCOMMANDER.rc"
contextfile="$SC_CONTEXT/.$SUBCOMMANDER.context"

fmt <<- EOF
	The following variables (and only these) are added to the environment of
	executed subcommands:

	The name of this subcommander-based tool:

	    SUBCOMMANDER=$SUBCOMMANDER

	The current context:

	    SC_CONTEXT=$SC_CONTEXT

	$SUBCOMMANDER will execute the following, in order, if they exist and are
	executable. These scripts or programs are *executed*, not sourced, and may
	be implemented in any language. To function properly, both executables must
	call or exec() their argument list. It is expected that the user may call
	hook scripts or modify the environment within these programs before calling
	the subcommand passed as the argument.

EOF

echo "    $sc_rcfile"
echo
[ -e "$sc_rcfile" ] && ans='Yes' || ans='No'
echo "               exists: $ans"

[ -x "$sc_rcfile" ] && ans='Yes' || ans='No'
echo "        is executable: $ans"
echo

echo "    $contextfile"
echo
[ -e "$contextfile" ] && ans='Yes' || ans='No'
echo "               exists: $ans"

[ -x "$contextfile" ] && ans='Yes' || ans='No'
echo "        is executable: $ans"
echo

cat <<- EOF
	Other state information follows:

	\`pwd\`=`pwd`
	\$0=$0

EOF


if [ ! "$SC_CONTEXT" ]; then
	cat <<- EOF
		# Note: there is no current context defined. Or as git would say,
		fatal: Not a $SUBCOMMANDER workspace (or any of the parent directories): .$SUBCOMMANDER.context
	EOF
	exit 1
fi
